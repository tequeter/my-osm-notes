#!/usr/bin/perl -T
# Matija Nalis <mnalis-git-openstreetmap@voyager.hr> GPLv3+ started 20150201
# show only open notes for user(s) requested

use strict;
use warnings;
use autodie;
use feature 'say';
use open OUT => ':utf8';

use Encode;
use CGI qw(-utf8);
use CGI::Carp;
use URI::Escape;
use DB_File;
use DBM_Filter;
use List::MoreUtils qw(uniq);
use Time::Piece;
use Getopt::Long;

my $DB_NOTES_FILE = 'notes-txt.db';		# Note: same as in myosmnotes_parser.pl
my $DB_USERS_FILE = 'users.db';			# Note: same as in myosmnotes_parser.pl

binmode STDOUT, ":encoding(UTF-8)";
binmode STDERR, ":encoding(UTF-8)";

my $ignoreold = 0;
my @users;
GetOptions(
    "ignore-older-than=i" => \$ignoreold,
    "user=s"              => \@users,
) or die "Error in command-line arguments\n";

my $db_mtime = (stat($DB_USERS_FILE))[9];


# case insensitive compare of hash keys
sub db_compare {
    my($key1, $key2) = @_;
    lc $key1 cmp lc $key2;
}
$DB_BTREE->{'compare'} = \&db_compare;
                                                                
my $DB_user = tie my %USER, "DB_File", "$DB_USERS_FILE", O_RDONLY, 0444, $DB_BTREE or die "no DB $DB_USERS_FILE: $!";
$DB_user->Filter_Key_Push('utf8');

my $DB_note = tie my %NOTE, "DB_File", "$DB_NOTES_FILE", O_RDONLY or die "no DB $DB_NOTES_FILE: $!";;
$DB_note->Filter_Value_Push('utf8');

my @all_notes = ();
say 'Searching for OSM Notes for users: ';
foreach my $org_key (@users) {
    my $found_key = $org_key;
    my $value = ''; $DB_user->seq($found_key, $value, R_CURSOR );	# this will actually update $found_key to what is in the database, not what was provided (which could be in different case, since we're case insensitive due to db_compare() override! )

    if ( ($found_key ne $org_key) and (lc $found_key ne lc $org_key) ) { $value = ''; $found_key = $org_key; }		# note however, $DB_user->seq() will return partial matches too, which we don't want, so make sure we only match keys whose only difference is case
    my @user_notes = split ' ', $value;
    push @all_notes, @user_notes;
    printf "%s has %d open notes\n", $found_key, (scalar @user_notes);
}

if (@all_notes) {
    my $format = "%8s  %-22s  %s\n";
    printf $format, "Note ID", "Opened", "Comment";
    foreach my $n (uniq sort {$a <=> $b} @all_notes) {
      my ($note_time, $note_text) = split / /, $NOTE{$n}, 2;
      $note_time =~ s/T/ /; $note_time =~ s/Z/ GMT/;
      my $days_old = int ((gmtime() - Time::Piece->strptime($note_time, '%Y-%m-%d %H:%M:%S %Z'))/86400);
      if ($days_old < $ignoreold or !$ignoreold) {
          chomp $note_text;
          if ($note_text =~ /\n/ || length $note_text > 40) {
              $note_text =~ s/^/  > /xmsg;
              $note_text = "\n$note_text";
          }
          printf $format, $n, $note_time, $note_text;
      }
    }
} else {
    say 'No open notes found.';
}

say 'Database was last updated: ' . localtime($db_mtime);

exit 0;
